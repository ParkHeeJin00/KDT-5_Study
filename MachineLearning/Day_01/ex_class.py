# 클래스 생성 (1) ---------------------------------------------
# - 구성 요소 : 속성 + 메서드 => 모두 없는 클래스
# - 기본 상속 : Object __속성명__, __메서드명__() # Object 클래스가 가지고 있는 속성과 메서드
# -----------------------------------------------------------
class A:
    pass

# 클래스 생성 (2) ---------------------------------------------
# - 구성 요소 : 속성 + 메서드 => 인스턴스 변수와 메서드
# - 기본 상속 : Object __속성명__, __메서드명__() # Object 클래스가 가지고 있는 속성과 메서드
# -----------------------------------------------------------
class B:

    # 인스턴스 객체 생성 및 속성 초기화 메서드
    def __init__(self,num,name):
        # self로 지정된 힙 메모리 주소에서부터 속성 저장
        self.num=num
        self.name=name

    # 인스턴스 메서드
    def printInfo(self):
        print(f'name   : {self.num}')
        print(f'name   : {self.name}')

    # 연산자 맵핑 메서드 구현
    # 연산자 +와 맵핑된 메서드
    def __add__(self,other):  # 인스턴스끼리 덧셈 연산할 때, 아래 코드를 실행해라
        print('__add__')
        return self.num + other.num, self.name + other.name   # 튜플로 반환

    def __sub__(self,other):
        print('__sub__')
        return self.num - other.num
# 클래스 생성 (3) ---------------------------------------------
# - 구성 요소 : 속성 + 메서드 => 인스턴스 변수와 메서드, 클래스 변수
# - 기본 상속 : Object __속성명__, __메서드명__() # Object 클래스가 가지고 있는 속성과 메서드
# -----------------------------------------------------------
class C:

    # 클래스 변수 => C 클래스로 생성된 모든 인스턴스에서 공유
    # 인스턴스 생성 없이 사용 가능
    loc = 'daegu'
    def __init__(self,num,name):
        # self로 지정된 힙 메모리 주소에서부터 속성 저장
        self.num=num
        self.name=name

    # 인스턴스 메서드
    def printInfo(self):
        print(f'name   : {self.num}')
        print(f'name   : {self.name}')

# 클래스 생성 (4) ---------------------------------------------
# - 구성 요소 : 속성 + 메서드 => 클래스 변수와 메서드
# - 기본 상속 : Object __속성명__, __메서드명__() # Object 클래스가 가지고 있는 속성과 메서드
# -----------------------------------------------------------
class DCalc:

    # 클래스 변수 => C 클래스로 생성된 모든 인스턴스에서 공유
    # 인스턴스 생성 없이 사용 가능
    name = 'CASIO'

    # 클래스 메서드
    @classmethod    # cls 정보를 자동으로 넣어줌
    def addnum(cls,a,b):
        print(cls.name)
        return a+b
    def minusnum(cls,a,b):  # 매개변수를 총 세개 다 넣어줘야 함
        return a-b

# 일반함수 ---------------------------------------------------
def test(a,b):
    return a+b

def test(a,b,c):
    return a+b+c

# 원래 함수의 이름이 같더라도 매개변수가 다르다면 다른 함수로 인식하지만
# 파이썬은 마지막으로 정의된 함수로 덮어써짐
# 오버로딩은 함수의 매개변수의 개수나 타입, 순서가 바뀌는 것
# 오버라이딩은 함수를 상속받을때 코드만 바뀌는 것, 이름과 매개변수가 바뀌면 안됨 - 반드시
# ----------------------------------------------------------


# test(10,20) ==> Error 발생

# 객체/인스턴스 생성 --------------------------------------------
# => 생성 함수 : 클래스이름( __init__ 메서드 매개변수 )
# =>A()
# => B(num, name)
# ------------------------------------------------------------
a1 = A()   # a1은 A() 객체의 주소값을 가지고 있음
b1 = B(100,'BB')
b2 = B(30,'B2')
c1 = C(100,'CC')

# 객체/인스턴스의 연산 --------- --------------------------------------------
print(b1 + b2)
print(b1 - b2)

# 객체/인스턴스의 속성/메서드 사용 --------------------------------------------
# => 사용 방법 : 객체/인스턴스 변수명.속성
#               객체/인스턴스 변수명.메서드()
# ------------------------------------------------------------
print("A 인스턴스 a1의 속성과 메서드 =>", a1.__dict__)  # dict는 내 것만 => 빈 값
print("A 인스턴스 a1의 속성과 메서드  =>", a1.__dir__())   # dir은 내것 + 상속받은 것
print("A 클래스의 속성과 메서드 =>", A.__dict__)  # 클래스의 속성과 메서드를 반환

# 인스턴스 메서드 사용
c1.printInfo()

# 인스턴스 속성 사용
print(c1.name)

# 클래스 속성 사용
print(f'loc => {C.loc},{c1.loc}')  # C.loc 는 객체 생성 없이도 사용 가능 # c1.loc는 c1객체가 없다면 사용 불가

# 인스턴스 메서드는 클래스명으로 사용 불가
# C.printInfo()

# 클래스 속성 및 메서드 사용
print(f'DCalc.name : {DCalc.name}')
print(f'DCalc.addnum(10,20) : {DCalc.addnum(10,20)}')
# #print(f'DCalc.minusnum(10,20) : {DCalc.minusnum(10, 20)}') # 오류남. 매개변수 부족
print(f'DCalc.minusnum(DCalc,10,20) : {DCalc.minusnum(DCalc,10,20)}')