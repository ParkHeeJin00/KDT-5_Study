# ------------------------------------------------------------------------------
#  사용자 정의 클래스
# ------------------------------------------------------------------------------
# 클래스 정의 : 밤 하늘의 별을 저장하는 데이터
# 클래스 이름 : Star
# 클래스 속성 : 크기, 색상, 밝기  => 속성(attribute), 필드(field)  => 변수
# 클래스 기능 : 반짝거린다. 떨어진다. =>  함수(function), 메서드(method)  => 함수
# ------------------------------------------------------------------------------
class Star:
    # 클래스 변수/속성/필드 => 해당 클래스로 생선된 객체 즉 인스턴스가 공유하는 속성
    timezone = '밤'
    __privateValue = '비밀 인스턴스(객체) 변수'
        
    # 최상위 부모 클래스 object로부터 상속받은 함수 즉 메서드
    # 형태 def _ _XXX_ _ ()
    # 나의 클래스에 맞도록 수정 즉 리모델링해서 사용 => 오버라이드(override)    ## 함수를 상속받고 내 입맛에 맞게 고치기
    def __init__(self, size, color, brightness, name = '알수없음'):   ## 객체(인스턴스)가 만들어져야 self 존재
        print(f'__init__() : {size}, {color}, {brightness}, {name}')
        # 힙 메모리 영역에 저장 +> 속성 데이터의 주소 저장
        # 비공개 속성 문법 => __속성명 => 접근 못하게 막음 => 비공개 => 변경 못함
        self.__size = size  ## 전달받은 속성의 주소를 전달
        self.color = color 
        self.brightness = brightness
        self.name = name  
        ## = myStar. = self.   ## 일단 myStar라는 객체에 접근해야 속성이 든 주소를 알 수 있음!
        ## 얘네들은 다 필드 즉 속성

    # 별 클래스의 기능 => 메서드
    def drop(self):
        print(f'{self.name} 별이 하늘에서 떨어집니다. 소원 빌어요~!')
        print(f'{self.color} 별이 하늘에서 떨어집니다. 소원 빌어요~!')

    # 비공개 인스턴스 속성에 접근하기 위한 메서드 => getter/setter 메서드
    # 비공개 인스턴스 속성 읽어오는 메서드 get속성명() => 속성값
    # 비공개 인스턴스 속성에 값 설정하는 메서드 set속성명(새로운 값)
    def getSize(self):   
        return self.__size
    def setSize(self, size):
        self.__size = size
    ## 보는 것만 가능하게 하고 싶으면 get만 변경도 가능하게 하려면 set 둘다 싫으면 안만들면 됨 => 선택값

    # 비공개 인스턴스 메서드 => 클래스 내부에서만 호출되는 메서드 ------------------------   
    def __inner(self):   
        print('나는 비공개 인스턴스 메서드')

    # 데코레이터 문법 - 함수의 기능을 미리 설명 / 비공개 메서드 지정
        
    # 비공개 메서드 지정 - getter/setter 메서드를 편하게 해주기 위해 나온 메서드
    ## 메서드 위에 붙어서 속성(property)에 특별한 기능을 줌
    @property     

    # 객체 즉 인스턴스 생성 없이 사용하는 메서드 - 속성이 없고 기능만 있으면 self(인스턴스 즉 객체)가 필요X => @staticmethod 사용
    @staticmethod
    def add():
        pass
    # 힙 영역에 들어있는 클래스 정보에 접속 가능
    # @classmethod
    # def cc(cls):
    #     pass

# 모든 클래스가 속성과 기능 둘다 있어야 하는 것 아님 
     
# ------------------------------------------------------------------------------
#  객체 생성 => 클래스에 정의된 속성 즉 변수와 함수들이 메모리 힙 영역에 생성
#  생성 방법 => 클래스명() 생성자 함수/메서드
#              클래스명(매개변수1) 생성자 함수/메서드
#              클래스명(매개변수1, 매개변수2,..,매개변수n) 생성자 함수/메서드
# ------------------------------------------------------------------------------
myStar = Star(5,'dark_yellow',10)
yourStar = Star(10,'red', 20, 'RedStar')

# ------------------------------------------------------------------------------
# 객체의 메서드 실행 => 객체변수명.메서드명()
# ------------------------------------------------------------------------------
myStar.drop()
yourStar.drop()
myStar

# ------------------------------------------------------------------------------
# 객체의 속성 정보 읽기 => 객체변수명.속성명
# ------------------------------------------------------------------------------

# 인스턴스 속성에 직접 접근 - 비공개 속성은 안됨 # myStar.__size X

print(myStar.brightness, myStar.timezone)
print(yourStar.brightness, yourStar.timezone)


# 인스턴스 속성에 간접 접근 => 메서드 제공함수 getter/setter 메서드

# 현재 비공개 속성값 일기
print(myStar.getSize())
# 현재 비공개 속성값 변경
myStar.setSize(100)
# 바뀐 비공개 속성값 확인
print(myStar.getSize())  

# ------------------------------------------------------------------------------
# 객체의 속성 정보 변경 => 객체변수명.속성명 = 새로운 값
# ------------------------------------------------------------------------------
myStar.brightness = 7  ## 7의 주소를 다시 넣기
print( myStar.brightness)

# ------------------------------------------------------------------------------
print(f'인스턴스 명.__dict__ : \n{myStar.__dict__}')  ## 속성들 이름과 값 프린트
print(f'인스턴스 명.__dict__ : \n{yourStar.__dict__}')